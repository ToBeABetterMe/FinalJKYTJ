package com.health.measurement;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import android.util.Log;

import com.c102c.app.bluetooth.BluetoothService;
import com.c102c.app.utils.MyArrays;

public class HealthDevice {
	/**
	 * 将收到的多条数据根据头标志分割，
	 * 
	 * @param buffer
	 * @return
	 */
	private static boolean state = true;
	private static PersistWriter lastInstance = null;

	public static List<byte[]> splitBufferData(byte[] buffer, byte[] head) {
		List<byte[]> datas = new ArrayList<byte[]>();
		// 每条独立的数据的前五个字节大小是固定的,最短的数据为6个字节
		int low = 0, high = buffer.length;// 初始假设只有一条数据

		for (int i = 2; i < buffer.length; i++) {
			if (buffer[i - 1] == head[0] && buffer[i] == head[1]) {
				high = i - 1;
				datas.add(MyArrays.copyOfRange(buffer, low, high));
				low = high;
			}
		}
		datas.add(MyArrays.copyOfRange(buffer, low, buffer.length));// 最后一条数据
		return datas;
	}

	public static PersistWriter getAuthority(BluetoothService bluetoothService,
			byte[] command, long sleepTime) {
		if (lastInstance != null) {
			if (lastInstance.bluetoothService == bluetoothService)
				return lastInstance;// 返回之前建立的实例
			else
				lastInstance.stop();// handler不同表示要连接不同的设备，需要把上次连接断掉
		}
		lastInstance = new PersistWriter(bluetoothService, command, sleepTime);
		return lastInstance;
	}

	/**
	 * 
	 * 持续传递命令，以让蓝牙保持连接
	 * 
	 */
	public static class PersistWriter extends Thread {
		private BluetoothService bluetoothService;
		private static final String TAG = "PC300.PersistWriter";
		private byte[] command;// 传递的命令
		private long sleepTime;// 间隔时间

		public PersistWriter(BluetoothService bluetoothService, byte[] command,
				long sleepTime) {
			this.bluetoothService = bluetoothService;
			this.command = command;
			this.sleepTime = sleepTime;
		}

		@Override
		public void run() {
			while (state) {
				if (bluetoothService.getState() == BluetoothService.STATE_CONNECTED) {
					//Log.i(TAG, "send persist command");
					try {
						bluetoothService.write(command);// 电量命令
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
				try {
					TimeUnit.MILLISECONDS.sleep(sleepTime);// 每隔一段时间发送一次电量查询命令
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}

		public void close() {
			state = false;
		}

		public void mystart() {
			state = true;
		}
	}

}
